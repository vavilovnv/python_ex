"""
Калькулятор.

Задание связано с обратной польской нотацией. Она используется для парсинга
арифметических выражений. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

Пример 1:
3 4 +
означает 3 + 4 и равно 7

Пример 2:
12 5 /
Так как деление целочисленное, то в результате получим 2.

Пример 3:
10 2 4 * -
означает 10 - 2 * 4 и равно 2

Разберём последний пример подробнее:
Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию,
которую этот знак обозначает, то есть перемножить эти два числа. В результате
получим 8.
После этого выражение приобретёт вид:
10 8 -
Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и
8. В итоге получаем 2.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать
стек. Для вычисления значения выражения, записанного в обратной польской
нотации, нужно считывать выражение слева направо и придерживаться следующих
шагов:

1. Обработка входного символа:
Если на вход подан операнд, он помещается на вершину стека.
Если на вход подан знак операции, то эта операция выполняется над требуемым
количеством значений, взятых из стека в порядке добавления. Результат
выполненной операции помещается на вершину стека.
2. Если входной набор символов обработан не полностью, перейти к шагу 1.
3. После полной обработки входного набора символов результат вычисления
выражения находится в вершине стека. Если в стеке осталось несколько чисел,
то надо вывести только верхний элемент.

Замечание про отрицательные числа и деление: в этой задаче под делением
понимается математическое целочисленное деление. Это значит, что округление
всегда происходит вниз. А именно: если a / b = c, то b ⋅ c — это наибольшее
число, которое не превосходит a и одновременно делится без остатка на b.

Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление
чисел работает иначе.

В текущей задаче гарантируется, что деления на отрицательное число нет.

Формат ввода
В единственной строке дано выражение, записанное в обратной польской нотации.
Числа и арифметические операции записаны через пробел.
На вход могут подаваться операции: +, -, *, / и числа, по модулю не
превосходящие 10000.
Гарантируется, что значение промежуточных выражений в тестовых данных по
модулю не больше 50000.

Формат вывода
Выведите единственное число — значение выражения.

Пример 1
Ввод
2 1 + 3 *
Вывод
9
Пример 2

Ввод
7 2 + 4 * 2 +
Вывод
38
"""

from typing import List, Optional


class Stack:
    """Класс реализующий стек на основе списка, с функцией расчета
    значения переданного выражения в обратной польской нотации."""

    def __init__(self) -> None:
        """Инициализация стека для хранения чисел и промежуточных
        результатов."""

        self.__stack = []
        self.__size = 0
        self.__operations = {
            '+': lambda a, b: a + b,
            '-': lambda a, b: a - b,
            '*': lambda a, b: a * b,
            '/': lambda a, b: a // b
        }

    def __get_data(self, index: int) -> Optional[int]:
        """Получение элемента из стека с проверкой возможности получения."""

        if self.__size == 0:
            raise RuntimeError('Попытка получения элемента из пустого стека.')
        try:
            value = self.__stack.pop(index)
        except IndexError:
            print(
                f'Ошибка получения элемента из стека по индексу {index}'
            )
        else:
            self.__size -= 1
            return value

    def __push_data(self, value: int) -> None:
        """Добавление элемента в стек."""

        self.__size += 1
        self.__stack.append(value)

    def calculate(self, data: List[str]) -> int:
        """Вычисление выражения в обратной польской нотации."""

        while len(data) > 0:
            value = data.pop(0)
            if value in self.__operations:
                # если встретилась операция, берем два элемента из стека
                a = self.__get_data(-2)
                b = self.__get_data(-1)
                # пушим в стек вычисление для пары a и b
                self.__push_data(self.__operations[value](a, b))
            else:
                # пока не встретилась операция, заполняем стек
                self.__push_data(int(value))
        return self.__stack[-1]


def main():
    data = input().strip().split()
    stack = Stack()
    print(stack.calculate(data))


if __name__ == '__main__':
    main()
