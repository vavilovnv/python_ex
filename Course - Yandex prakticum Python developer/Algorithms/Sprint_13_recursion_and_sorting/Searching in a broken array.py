"""
Поиск в сломанном массиве.

Алла ошиблась при копировании из одной структуры данных в другую. Она хранила
массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в
нём можно было найти элемент за логарифмическое время. Алла скопировала данные
из кольцевого буфера в обычный массив, но сдвинула данные исходной
отсортированной последовательности. Теперь массив не является отсортированным.
Тем не менее, нужно обеспечить возможность находить в нем элемент за O(log n).

Можно предполагать, что в массиве только уникальные элементы.

От вас требуется реализовать функцию, осуществляющую поиск в сломанном 
массиве. 

Формат ввода
Функция принимает массив натуральных чисел и искомое число k. Длина массива не
превосходит 10000. Элементы массива и число k не превосходят по значению
10000.

В примерах:
В первой строке записано число n — длина массива. Во второй строке записано
положительное число k — искомый элемент. Далее в строку через пробел записано
n натуральных чисел – элементы массива.

Формат вывода
Функция должна вернуть индекс элемента, равного k, если такой есть в массиве
(нумерация с нуля). Если элемент не найден, функция должна вернуть - 1.
Изменять массив нельзя. Для отсечения неэффективных решений ваша функция будет
запускаться от 100000 до 1000000 раз.

Пример 1
Ввод
9
5
19 21 100 101 1 4 5 7 12
Вывод
6

Пример 2
Ввод
2
1
5 1
Вывод
1
"""

from typing import List


def get_target_index(
    arr: List[int],
    left: int,
    right: int,
    target: int
    ) -> int:
    """Бинарный поиск индекса целевого элемента target в отсортированном
    списке. Если такой элемент не найден, функция возвращает -1."""

    if left > right:
        return -1
    half = (left + right) // 2
    if arr[half] == target:
        return half
    if arr[half] > target:
        right = half - 1
    else:
        left = half + 1
    return get_target_index(arr, left, right, target)


def get_broken_index(arr: List[int], left: int, right: int) -> int:
    """Бинарный поиск индекса наименьшего элемента исходной отсортированной
    последовательности в списке из двух отсортированных частей. Данный
    список является поломанной исходной последовательностью."""

    if left == right:
        return left
    half = (left + right) // 2
    if arr[half] >= arr[right]:
        left = half + 1
    else:
        right = half
    return get_broken_index(arr, left, right)


def broken_search(nums: List[int], target: int) -> int:
    """Функция выполняет бинарный поиск индекса опорного элемента в списке
    из двух отсортированных частей исходной последовательности, поломанной при
    копировании.

    Проверяется частный случай равенства опорного элемента целевому элементу
    target. Если это не так, выполняется бинарный поиск целевого элемента
    target в одной из отсортированных частей исходной последовательности,
    которая его содержит.

    Если целевого элемента в списке нет, возвращается значение -1."""

    length = len(nums) - 1
    broken = get_broken_index(nums, 0, length)
    if nums[broken] == target:
        return broken
    if nums[0] == target:
        return 0
    if nums[0] < target:
        left, right = 0, broken - 1 if broken > 0 else length
    else:
        left, right = broken + 1, length
    return get_target_index(nums, left, right, target)


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6


if __name__ == '__main__':
    # по условию считывать данные не требуется, поэтому запускаем на
    # выполнение только функцию тестирования с готовыми данными
    test()
